%%

clear; close all; clc;

%% -------------------- Step A: Define Problem Parameters --------------------
N = 10;                     % number of rows
RL = 20;                    % row length
W = 2.5;                    % implement width (row spacing)
L = 3;                      % tractor length
Ld = 1.5;                   % look-ahead distance
gamma_limit = deg2rad(60);  % steering limit
Rmin = L / tan(gamma_limit);  % minimum turning radius

% Start and end positions
x_start = -3 * W;
y_start = RL / 2;
x_end = x_start;
y_end = y_start;

% Coordinates of headland nodes (lower and upper)
x_lower = W + 2.5 * (0:N-1); % added 2.5 m to correct X coordinates
y_lower = zeros(1, N);

x_upper = x_lower;
y_upper = RL * ones(1, N);

% Assemble full node coordinate list (1=start, 2..N+1=lower, N+2..2N+1=upper, 2N+2=end)
x = [x_start, x_lower, x_upper, x_end];
y = [y_start, y_lower, y_upper, y_end];

% Plot for verification
figure; plot(x, y, 'ko'); text(x + 0.2, y + 0.2, string(1:2*N+2)); axis equal;
title('Node Layout Verification'); xlabel('X [m]'); ylabel('Y [m]');
status = mkdir('results');
saveas(gcf, "results\node_layout.png")

%% -------------------- Step B: Build Cost Matrix --------------------
HUGE = 1e6; % Large penalty value
DMAT = HUGE * ones(2*N+2); % Initialize with large values

% 1. Row traversal cost (zero cost between lower-upper of the same row)
for i = 2:N+1 % lower nodes
    for j = N+2:2*N+1 % upper nodes
        if (j - i) == N
            DMAT(i,j) = 0; % row traversal is "free"
            DMAT(j,i) = 0;
        end
    end
end

% 2. Headland turning costs (Π or Ω turns)
for i = 2:N                    % bottom nodes only
    for j = i+1:N+1            % look only to the right of i
        d       = j - i;       % |i-j|  (guaranteed ≥1 here)
        spacing = d * W;       % lateral distance between the rows

        if spacing > 2*Rmin    % ⇒ Π-turn is feasible
            % ── Π-turn length = 180° arc + (d-1) straight gaps ──
            half_circle = pi * Rmin;          % 180° arc
            straight    = (d-1) * W;          % bridge between rows
            cost        = half_circle + straight;
        else                   % ⇒ use Ω-turn
            % ── Ω-turn length = two 180° arcs back-to-back ──
            cost = 2 * pi * Rmin;
        end

        % write cost symmetrically for bottom & top nodes
        DMAT(i,      j     ) = cost;
        DMAT(j,      i     ) = cost;
        DMAT(i+N,    j+N   ) = cost;
        DMAT(j+N,    i+N   ) = cost;
    end
end

% 3. Manhattan distances from start and end nodes to all field nodes
for i = 2:2*N+1
    DMAT(1,i) = abs(x(1) - x(i)) + abs(y(1) - y(i));
    DMAT(i,1) = DMAT(1,i); % symmetry

    DMAT(2*N+2,i) = abs(x(2*N+2) - x(i)) + abs(y(2*N+2) - y(i));
    DMAT(i,2*N+2) = DMAT(2*N+2,i); % symmetry
end

% 4. Prohibit direct start-to-end transitions
DMAT(1,2*N+2) = HUGE;
DMAT(2*N+2,1) = HUGE;

% Add penalties for crossing the field diagonally (disable jumps not to neighbor rows)
for i = 2:N+1  % lower nodes
     for j = 2:N+1  % other lower nodes
         if abs(i - j) > 1
             DMAT(i, j) = HUGE;
             DMAT(i + N, j + N) = HUGE;
         end
     end
end


%% -------------------- Solve TSP (Step B Completion) --------------------
XY = [x', y'];
t = cputime;
resultStruct = tspof_ga('xy', XY, 'DMAT', DMAT, ...
                        'SHOWRESULT', true, ...
                        'SHOWWAITBAR', true, ...
                        'SHOWPROG', true);
E = cputime - t; % computation time

route = [1, resultStruct.optRoute, 2*N+2]; % full node sequence

% Output result
disp('Computed Optimal Route (Node Indices):');
disp(route);
disp(['Computed Minimum Distance: ', num2str(resultStruct.minDist)]);
disp(['Computation Time: ', num2str(E), ' seconds']);

% Save output
% Open a new file (or overwrite if it exists)
fid = fopen('results\results.txt','w');

% Write each piece
fprintf(fid, 'Computed Optimal Route (Node Indices):\n');
fprintf(fid, '%d ', route);          % print each index with a space
fprintf(fid, '\n\n');                % blank line

fprintf(fid, 'Computed Minimum Distance: %.4f\n', resultStruct.minDist);
fprintf(fid, 'Computation Time: %.4f seconds\n', E);

% Close the file
fclose(fid);

%% Plot Solution
figure; plot(x(route), y(route), 'r-o', 'LineWidth', 2);
hold on; plot(x, y, 'ko'); text(x + 0.2, y + 0.2, string(1:2*N+2));
title('Optimal Node Sequence Visualization');
xlabel('X [m]'); ylabel('Y [m]'); axis equal;

%% -------------------- Step C: Generate Waypoints Along the Node Sequence --------------------
waypoints = [];
waypointSegment = [];

% route has length M = numel(route)
for k = 1:numel(route)-1
    i = route(k);
    j = route(k+1);
    p1 = [ x(i), y(i) ];
    p2 = [ x(j), y(j) ];

    % determine newPts for this link
    if k == 1
        % -- entry turn: start -> first field node
        theta0 = 0;
        if j >= 2 && j <= N+1
            theta1 = pi/2;
        else
            theta1 = -pi/2;
        end
        P      = dubins_core([p1,theta0],[p2,theta1], Rmin);
        pts    = dubins_path_sample_many(P, 0.25);
        newPts = pts(2:end,1:2);

    elseif k == numel(route)-1
        % -- exit turn: last field node -> end
        if i >= 2 && i <= N+1
            theta0 = -pi/2; % come north in bottom headland
        else
            theta0 = pi/2;  % come south in top headland
        end
        theta1 = pi;    % face west toward end point
        P      = dubins_core([p1,theta0],[p2,theta1], Rmin);
        pts    = dubins_path_sample_many(P, 0.25);
        newPts = pts(2:end,1:2);

    else
        % -- middle links
        % 1) straight row traversal?
        paired = ( (i>=2 && i<=N+1 && j-i==N) || ...
                   (j>=2 && j<=N+1 && i-j==N) );
        if paired
            nPts   = ceil(norm(p2-p1)/0.5);
            xs     = linspace(p1(1),p2(1),nPts).';
            ys     = linspace(p1(2),p2(2),nPts).';
            newPts = [ xs(2:end), ys(2:end) ];

        else
            % 2) headland Π/Ω turn?
            sameBottom = all([i j] >= 2      & [i j] <= N+1);
            sameTop    = all([i j] >= N+2    & [i j] <= 2*N+1);
            if sameBottom || sameTop
                if sameBottom
                    theta0 = -pi/2;   % south→north
                    theta1 =  pi/2;
                else
                    theta0 =  pi/2;   % north→south
                    theta1 = -pi/2;
                end
                P      = dubins_core([p1,theta0],[p2,theta1], Rmin);
                pts    = dubins_path_sample_many(P, 0.25);
                newPts = pts(2:end,1:2);

            else
                % 3) straight link (start/end approaches or any other)
                nPts   = ceil(norm(p2-p1)/0.5);
                xs     = linspace(p1(1),p2(1),nPts).';
                ys     = linspace(p1(2),p2(2),nPts).';
                newPts = [ xs(2:end), ys(2:end) ];
            end
        end
    end

    % append
    waypoints       = [ waypoints;       newPts ];
    waypointSegment = [ waypointSegment; k*ones(size(newPts,1),1) ];
end

% Plot the generated waypoints
figure; plot(waypoints(:,1), waypoints(:,2), 'b.-'); axis equal;
title('Generated Waypoints from Node Sequence');
xlabel('X [m]'); ylabel('Y [m]');
saveas(gcf, "results\waypoints.png")

%% -------------------- Step D: Simulate Path Following with Pure Pursuit Controller --------------------

clear q_history cte_history

% Reset Integration Parameters
global dt DT
dt = 0.001;    % 1 ms integration step
DT = 0.01;     % 10 ms control update period
T = 1000.0;      % run until it reaches the end point
time_vec = 0:DT:T-DT;

% Vehicle and Controller Parameters
L = 2.5;               % wheelbase
Ld = 1.0;              % look-ahead distance
gamma_max = deg2rad(45);
gamma_min = -gamma_max;
v_ref = 0.5;           % constant forward speed
tau_gamma = 0.0;       % instant steering dynamics
tau_v = 0.0;           % instant speed dynamics

% State bounds
Qmax = [inf; inf; inf; gamma_max; v_ref];
Qmin = [-inf; -inf; -inf; gamma_min; 0];

% Initial state [x, y, theta, gamma, v]
q = [-3*W; RL/2; 0; 0; v_ref];

numSteps    = length(time_vec);
q_history   = zeros(numSteps+1,5);    % assuming state q has length 5
cte_history = zeros(numSteps,1);

% store initial state
q_history(1,:) = q.';

for k = 1:numSteps
    % 1) compute steering
    [delta, cte] = purePursuitController(q, L, Ld, waypoints, waypointSegment);
    delta = max(min(delta,gamma_max),gamma_min);

    % 2) step the dynamics
    q = robot_bike_dyn( ...
          q, [delta; v_ref], ...
          [gamma_min;0], [gamma_max;v_ref], ...
          Qmin, Qmax, L, 0, 0 );

    % 3) record state
    q_history(k+1,:) = q.';

    % 4) compute and store CTE
    cte_history(k) = computeCrosstrackError(q, waypoints);

    % 5) check termination
    if norm(q(1:2) - waypoints(end,:).') < 0.1 || k == 
        % trim unused entries
        q_history   = q_history(1:k+1,:);
        cte_history = cte_history(1:k);
        break;
    end
end


% results
rms_cte = sqrt(mean(cte_history.^2));
disp(['Adaptive Ld RMS CTE: ', num2str(rms_cte), ' m']);

% save figures as before
figure;
plot(wp(:,1), wp(:,2), 'r--'); hold on;
plot(q_history(:,1), q_history(:,2), 'b-');
axis equal; grid on;
title('Adaptive Ld Path Following');
xlabel('X [m]'); ylabel('Y [m]');
saveas(gcf, 'results\adaptive_robot_path.png');

figure;
t = (0:DT:(numel(cte_history)-1)*DT).';
plot(t, cte_history);
grid on;
title('Adaptive Ld Cross-Track Error');
xlabel('Time [s]'); ylabel('CTE [m]');
saveas(gcf, 'results\adaptive_cte.png');

% save RMS
fid = fopen('results\RMS_adaptive.txt','w');
fprintf(fid, 'RMS CTE (adaptive Ld): %.4f\n', rms_cte);
fclose(fid);

%% -------------------- Step E: Simulate with ±30° Steering on Same Path --------------------

% steering limits
gamma_limit_30 = deg2rad(30);
gamma_max30   = gamma_limit_30;
gamma_min30   = -gamma_limit_30;

% reset simulation
clear q_history cte_history
dt = 0.001; DT = 0.01; T = 60.0;
time_vec = 0:DT:T-DT;
L = 2.5;              % wheelbase
Ld = 3;             % lookahead distance
v_ref = 1.0;          % constant speed

Qmax = [Inf; Inf; Inf; gamma_max30; v_ref];
Qmin = [-Inf; -Inf; -Inf; gamma_min30; 0];

% initial state [x; y; theta; steer; v]
q = [-3*W; RL/2; 0; 0; v_ref];

q_history = q.';
cte_history = [];

for k = 1:length(time_vec)
    [steerAngle, cte] = purePursuitController(q, L, Ld, waypoints);
    % saturate to ±30°
    steerAngle = max(min(steerAngle, gamma_max30), gamma_min30);
    control = [steerAngle; v_ref];

    q = robot_bike_dyn(q, control, [gamma_min30;0], [gamma_max30;v_ref], Qmin, Qmax, L, 0, 0);

    q_history = [q_history; q.'];
    cte_history = [cte_history; cte];

    if norm(q(1:2) - waypoints(end,:).') < 0.01
        % trim unused entries
        q_history   = q_history(1:k+1,:);
        cte_history = cte_history(1:k);
        break;
    end
end

% Plot & save
figure;
plot(waypoints(:,1), waypoints(:,2), 'r--','LineWidth',1.5); hold on;
plot(q_history(:,1), q_history(:,2), 'b-','LineWidth',1.5);
axis equal; grid on;
legend('Waypoints','Robot Path');
xlabel('X [m]'); ylabel('Y [m]');
title('Path Following with ±30° Steering');
saveas(gcf, 'results\robot_path_30deg.png');

figure;
tE = (0:DT:(length(cte_history)-1)*DT);
plot(tE, cte_history,'LineWidth',1.5);
xlabel('Time [s]'); ylabel('Cross-Track Error [m]');
title('CTE with ±30° Steering');
grid on;
saveas(gcf, 'results\cte_30deg.png');

% write RMS error
rms_cte_30 = sqrt(mean(cte_history.^2));
disp(['RMS CTE (±30°): ', num2str(rms_cte_30), ' m']);
fid = fopen('results\RMS_30deg.txt','w');
fprintf(fid, 'RMS CTE (m) with ±30° steering: %.4f\n', rms_cte_30);
fclose(fid);


%% -------------------- Step F: Re-run B→D with ±30° Steering (new Rmin) --------------------

% new turning radius
Rmin30 = L / tan(gamma_limit_30);

% rebuild cost matrix DMAT30 (same logic as Step B)
HUGE = 1e6;
DMAT30 = HUGE * ones(2*N+2);

% 1) free row traversal
for i = 2:N+1
    j = i+N;
    DMAT30(i,j) = 0;
    DMAT30(j,i) = 0;
end

% 2) headland turns with Rmin30
for i = 2:N
    for j = i+1:N+1
        d       = j - i;
        spacing = d * W;
        if spacing > 2*Rmin30
            cost = pi*Rmin30 + (d-1)*W;   % Π-turn
        else
            cost = 2*pi*Rmin30;           % Ω-turn
        end
        DMAT30(i,    j   ) = cost;
        DMAT30(j,    i   ) = cost;
        DMAT30(i+N, j+N ) = cost;
        DMAT30(j+N, i+N ) = cost;
    end
end

% 3) Manhattan to start/end
for i = 2:2*N+1
    DMAT30(1,   i   ) = abs(x(1)-x(i)) + abs(y(1)-y(i));
    DMAT30(i,   1   ) = DMAT30(1,i);
    DMAT30(end,i   ) = abs(x(end)-x(i)) + abs(y(end)-y(i));
    DMAT30(i,end   ) = DMAT30(end,i);
end

% 4) prohibit start<->end
DMAT30(1,end) = HUGE;
DMAT30(end,1) = HUGE;

% solve TSP again
result30 = tspof_ga('xy', XY, 'DMAT', DMAT30, 'SHOWRESULT', false);
route30 = [1, result30.optRoute, 2*N+2];

% Step C': regenerate waypoints30
waypoints30 = [];
for k = 1:numel(route30)-1
    i = route30(k); j = route30(k+1);
    p1 = [x(i), y(i)]; p2 = [x(j), y(j)];
    paired = ((i>=2 && i<=N+1 && j-i==N) || (j>=2 && j<=N+1 && i-j==N));
    if paired
        n = ceil(norm(p2-p1)/0.5);
        t = linspace(0,1,n).';
        waypoints30 = [waypoints30; (p1 + (p2-p1).*t(2:end))];
        continue
    end
    sb = all([i j]>=2 & [i j]<=N+1);
    st = all([i j]>=N+2 & [i j]<=2*N+1);
    if sb || st
        if sb, theta0 = -pi/2; theta1 = pi/2;
        else  theta0 = pi/2; theta1 = -pi/2; end
        P30   = dubins_core([p1,theta0],[p2,theta1],Rmin30);
        pts30 = dubins_path_sample_many(P30,0.25);
        waypoints30 = [waypoints30; pts30(2:end,1:2)];
        continue
    end
    n = ceil(norm(p2-p1)/0.5);
    t = linspace(0,1,n).';
    waypoints30 = [waypoints30; (p1 + (p2-p1).*t(2:end))];
end

figure; plot(waypoints30(:,1),waypoints30(:,2),'b.-'); axis equal;
title('Waypoints (±30° R_{min})');
saveas(gcf, 'results\waypoints_30deg.png');

% Step D': simulate on waypoints30
clear q_history cte_history
q = [-3*W; RL/2; 0; 0; v_ref];
q_history = q.'; cte_history = [];
for k = 1:length(time_vec)
    [steerAngle, cte] = purePursuitController(q, L, Ld, waypoints30);
    steerAngle = max(min(steerAngle, gamma_max30), gamma_min30);
    control = [steerAngle; v_ref];
    q = robot_bike_dyn(q,control,[gamma_min30;0],[gamma_max30;v_ref],Qmin,Qmax,L,0,0);
    q_history = [q_history; q.'];
    cte_history = [cte_history; cte];
    if norm(q(1:2)-waypoints30(end,:).')<0.5
        break;
    end
end

figure;
plot(waypoints30(:,1),waypoints30(:,2),'r--'); hold on;
plot(q_history(:,1),q_history(:,2),'b-');
axis equal; grid on;
title('Path Following on New Route (±30° Steering)');
saveas(gcf,'results\robot_path_new_30deg.png');

figure;
tF = (0:DT:(length(cte_history)-1)*DT);
plot(tF,cte_history);
grid on;
title('CTE on New Route (±30° Steering)');
saveas(gcf,'results\cte_new_30deg.png');

rms_cte_new = sqrt(mean(cte_history.^2));
disp(['RMS CTE (new route, ±30°): ',num2str(rms_cte_new),' m']);
fid = fopen('results\RMS_new_30deg.txt','w');
fprintf(fid,'RMS CTE (m) new route ±30°: %.4f\n', rms_cte_new);
fclose(fid);



%-----------------------Helper Functions----------------------------------

function param = dubins_core(p1, p2, r)
    %%%%%%%%%%%%%%%%%% DEFINE %%%%%%%%%%%%%%%%%
    % Here are some usefuldefine headers for better implementation
    % there are 6 types of dubin's curve, only one will have minimum cost
    % LSL = 1;
	% LSR = 2;
	% RSL = 3;
	% RSR = 4;
	% RLR = 5;
    % LRL = 6;
    
    % The three segment types a path can be made up of
    % L_SEG = 1;
    % S_SEG = 2;
    % R_SEG = 3;

    % The segment types for each of the Path types
    %{
    DIRDATA = [ L_SEG, S_SEG, L_SEG ;...
                L_SEG, S_SEG, R_SEG ;...
                R_SEG, S_SEG, L_SEG ;...
                R_SEG, S_SEG, R_SEG ;...
                R_SEG, L_SEG, R_SEG ;...
                L_SEG, R_SEG, L_SEG ]; 
    %}
    %%%%%%%%%%%%%%%% END DEFINE %%%%%%%%%%%%%%%%
            
    % the return parameter
    param.p_init = p1;              % the initial configuration
    param.seg_param = [0, 0, 0];    % the lengths of the three segments
    param.r = r;                    % model forward velocity / model angular velocity turning radius
    param.type = -1;                % path type. one of LSL, LSR, ... 
    param.flag = 0;
    
    %%%%%%%%%%%%%%%%%%%%%%%%% START %%%%%%%%%%%%%%%%%%%%%%%%%
    % First, basic properties and normalization of the problem
    dx = p2(1) - p1(1);
    dy = p2(2) - p1(2);
    D = sqrt( dx^2 + dy^2 );
    d = D / r;                  % distance is shrunk by r, this make lengh calculation very easy
    if( r <= 0 )
        param.flag = -1;
        return;
    end
    theta = mod(atan2( dy, dx ), 2*pi);
    alpha = mod((p1(3) - theta), 2*pi);
    beta  = mod((p2(3) - theta), 2*pi);

    % Second, we find all possible curves
    best_word = -1;
    best_cost = -1;
    test_param(1,:) = dubins_LSL(alpha, beta, d);
    test_param(2,:) = dubins_LSR(alpha, beta, d);
    test_param(3,:) = dubins_RSL(alpha, beta, d);
    test_param(4,:) = dubins_RSR(alpha, beta, d);
    test_param(5,:) = dubins_RLR(alpha, beta, d);
    test_param(6,:) = dubins_LRL(alpha, beta, d);
    
    for i = 1:1:6
        if(test_param(i,1) ~= -1) 
            cost = sum(test_param(i,:));
            if(cost < best_cost) || (best_cost == -1)
                best_word = i;
                best_cost = cost;
                param.seg_param = test_param(i,:);
                param.type = i;
            end
        end
    end

    if(best_word == -1) 
        param.flag = -2;             % NO PATH
        return;
    else
        return;
    end
end

function param = dubins_LSL(alpha, beta, d)
    tmp0 = d + sin(alpha) - sin(beta);
    p_squared = 2 + (d*d) -(2*cos(alpha - beta)) + (2*d*(sin(alpha) - sin(beta)));
    if( p_squared < 0 )
        param = [-1, -1, -1];
        return;
    else
        tmp1 = atan2( (cos(beta)-cos(alpha)), tmp0 );
        t = mod((-alpha + tmp1 ), 2*pi);
        p = sqrt( p_squared );
        q = mod((beta - tmp1 ), 2*pi);
        param(1) = t; 
        param(2) = p; 
        param(3) = q;
        return ;
    end
end
function param = dubins_LSR(alpha, beta, d)
    p_squared = -2 + (d*d) + (2*cos(alpha - beta)) + (2*d*(sin(alpha)+sin(beta)));
    if( p_squared < 0 )
        param = [-1, -1, -1];
        return;
    else
        p    = sqrt( p_squared );
        tmp2 = atan2( (-cos(alpha)-cos(beta)), (d+sin(alpha)+sin(beta)) ) - atan2(-2.0, p);
        t    = mod((-alpha + tmp2), 2*pi);
        q    = mod(( -mod((beta), 2*pi) + tmp2 ), 2*pi);
        param(1) = t; 
        param(2) = p; 
        param(3) = q;
        return ;
    end
end
function param = dubins_RSL(alpha, beta, d)
    p_squared = (d*d) -2 + (2*cos(alpha - beta)) - (2*d*(sin(alpha)+sin(beta)));
    if( p_squared< 0 ) 
        param = [-1, -1, -1];
        return;
    else
        p    = sqrt( p_squared );
        tmp2 = atan2( (cos(alpha)+cos(beta)), (d-sin(alpha)-sin(beta)) ) - atan2(2.0, p);
        t    = mod((alpha - tmp2), 2*pi);
        q    = mod((beta - tmp2), 2*pi);
        param(1) = t;
        param(2) = p; 
        param(3) = q;
        return ;
    end
end
function param = dubins_RSR(alpha, beta, d)
    tmp0 = d-sin(alpha)+sin(beta);
    p_squared = 2 + (d*d) -(2*cos(alpha - beta)) + (2*d*(sin(beta)-sin(alpha)));
    if( p_squared < 0 )
        param = [-1, -1, -1];
        return;
    else
        tmp1 = atan2( (cos(alpha)-cos(beta)), tmp0 );
        t = mod(( alpha - tmp1 ), 2*pi);
        p = sqrt( p_squared );
        q = mod(( -beta + tmp1 ), 2*pi);
        param(1) = t; 
        param(2) = p; 
        param(3) = q;
        return;
    end
end
function param = dubins_RLR(alpha, beta, d)
    tmp_rlr = (6. - d*d + 2*cos(alpha - beta) + 2*d*(sin(alpha)-sin(beta))) / 8.;
    if( abs(tmp_rlr) > 1)
        param = [-1, -1, -1];
        return;
    else
        p = mod(( 2*pi - acos( tmp_rlr ) ), 2*pi);
        t = mod((alpha - atan2( cos(alpha)-cos(beta), d-sin(alpha)+sin(beta) ) + mod(p/2, 2*pi)), 2*pi);
        q = mod((alpha - beta - t + mod(p, 2*pi)), 2*pi);
        param(1) = t;
        param(2) = p;
        param(3) = q;
        
        return;
    end
end
function param = dubins_LRL(alpha, beta, d)
    tmp_lrl = (6. - d*d + 2*cos(alpha - beta) + 2*d*(- sin(alpha) + sin(beta))) / 8.;
    if( abs(tmp_lrl) > 1)
        param = [-1, -1, -1]; return;
    else
        p = mod(( 2*pi - acos( tmp_lrl ) ), 2*pi);
        t = mod((-alpha - atan2( cos(alpha)-cos(beta), d+sin(alpha)-sin(beta) ) + p/2), 2*pi);
        q = mod((mod(beta, 2*pi) - alpha -t + mod(p, 2*pi)), 2*pi);
        param(1) = t;
        param(2) = p;
        param(3) = q;
        return;
    end
end
function path = dubins_curve(p1, p2, r, stepsize, quiet)
    
    %%%%%%%%%%%%%%%%%%%%%%%%% DEFINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % there are 6 types of dubin's curve, only one will have minimum cost
    % LSL = 1;
	% LSR = 2;
	% RSL = 3;
	% RSR = 4;
	% RLR = 5;
    % LRL = 6;
    
    % The three segment types a path can be made up of
    % L_SEG = 1;
    % S_SEG = 2;
    % R_SEG = 3;

    % The segment types for each of the Path types
    %{
    DIRDATA = [ L_SEG, S_SEG, L_SEG ;...
                L_SEG, S_SEG, R_SEG ;...
                R_SEG, S_SEG, L_SEG ;...
                R_SEG, S_SEG, R_SEG ;...
                R_SEG, L_SEG, R_SEG ;...
                L_SEG, R_SEG, L_SEG ]; 
    %}
            
    % the return parameter from dubins_core
    % param.p_init = p1;              % the initial configuration
    % param.seg_param = [0, 0, 0];    % the lengths of the three segments
    % param.r = r;                    % model forward velocity / model angular velocity turning radius
    % param.type = -1;                % path type. one of LSL, LSR, ... 
    %%%%%%%%%%%%%%%%%%%%%%%%% END DEFINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    % Handle inputs.
    if nargin < 3
        error('Function requires at least two inputs.');
    elseif nargin < 4
        stepsize = 0;
    elseif nargin < 5 
        quiet = 0;  %Default/undefined is not quiet
    end
    
    if ~quiet
        close(findobj('type','figure','name','Dubins curve'));
        tic;
    end
    
    % Check if the destination lies on the circle that can be reach
    % directly from the starting point
    if(p1(3)~=p2(3))
        T = [cos(p1(3)), sin(p1(3));...
             cos(p2(3)), sin(p2(3)) ];
        Y = [p1(1)*cos(p1(3)) + p1(2)*sin(p1(3)); ...
             p2(1)*cos(p2(3)) + p2(2)*sin(p2(3)) ];
        X = T \ Y;
        if( norm(X-reshape(p1(1:2), [2,1]),2) == r ) && ( norm(X-reshape(p2(1:2),[2,1]),2) == r )
            warning('p2 lies on the turning circle from the p2, dubins curve may be suboptimal');
        end
    end
        
    
    % main function
    param = dubins_core(p1, p2, r);
    if stepsize <= 0
        stepsize = dubins_length(param)/1000;
    end
    path = dubins_path_sample_many(param, stepsize);
    
    % plot if not quiet
    if ~quiet
        disp('dubins calculation time'); toc;
        % plotting
        tic;    % most of the time is spent on plotting
        figure('name','Dubins curve');
        plot(path(:,1), path(:,2)); axis equal; hold on
        scatter(p1(1), p1(2), 45, '*','r','LineWidth',1); hold on;
        scatter(p2(1), p2(2), 45, 'square','b','LineWidth',1); hold on;
        text(p1(1), p1(2),'start','HorizontalAlignment','center');
        text(p2(1), p2(2),'end','VerticalAlignment','top');
        disp('plot drawing time'); toc;
    end
end

function path = dubins_path_sample_many(param, stepsize)
    if param.flag < 0
        path = 0;
        return
    end
    length = dubins_length(param);
    path = -1 * ones(floor(length/stepsize), 3);
    x = 0;
    i = 1;
    while x <= length
        path(i, :) = dubins_path_sample( param, x );
        x = x + stepsize;
        i = i + 1;
    end
    return
end

function length = dubins_length(param)
    length = param.seg_param(1);
    length = length + param.seg_param(2);
    length = length + param.seg_param(3);
    length = length * param.r;
end


%{
 * Calculate the configuration along the path, using the parameter t
 *
 * @param path - an initialised path
 * @param t    - a length measure, where 0 <= t < dubins_path_length(path)
 * @param q    - the configuration result
 * @returns    - -1 if 't' is not in the correct range
%}
function end_pt = dubins_path_sample(param, t)
    if( t < 0 || t >= dubins_length(param) || param.flag < 0)
        end_pt = -1;
        return;
    end

    % tprime is the normalised variant of the parameter t
    tprime = t / param.r;

    % In order to take rho != 1 into account this function needs to be more complex
    % than it would be otherwise. The transformation is done in five stages.
    %
    % 1. translate the components of the initial configuration to the origin
    % 2. generate the target configuration
    % 3. transform the target configuration
    %      scale the target configuration
    %      translate the target configration back to the original starting point
    %      normalise the target configurations angular component

    % The translated initial configuration
    p_init = [0, 0, param.p_init(3) ];
    
    %%%%%%%%%%%%%%%%%%%%%%%%% DEFINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % The three segment types a path can be made up of
    L_SEG = 1;
    S_SEG = 2;
    R_SEG = 3;

    % The segment types for each of the Path types
    DIRDATA = [ L_SEG, S_SEG, L_SEG ;...
                L_SEG, S_SEG, R_SEG ;...
                R_SEG, S_SEG, L_SEG ;...
                R_SEG, S_SEG, R_SEG ;...
                R_SEG, L_SEG, R_SEG ;...
                L_SEG, R_SEG, L_SEG ]; 
    %%%%%%%%%%%%%%%%%%%%%%%%% END DEFINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Generate the target configuration
    types = DIRDATA(param.type, :);
    param1 = param.seg_param(1);
    param2 = param.seg_param(2);
    mid_pt1 = dubins_segment( param1, p_init, types(1) );
    mid_pt2 = dubins_segment( param2, mid_pt1,  types(2) );
    
    % Actual calculation of the position of tprime within the curve
    if( tprime < param1 ) 
        end_pt = dubins_segment( tprime, p_init,  types(1) );
    elseif( tprime < (param1+param2) ) 
        end_pt = dubins_segment( tprime-param1, mid_pt1,  types(2) );
    else 
        end_pt = dubins_segment( tprime-param1-param2, mid_pt2,  types(3) );
    end

    % scale the target configuration, translate back to the original starting point
    end_pt(1) = end_pt(1) * param.r + param.p_init(1);
    end_pt(2) = end_pt(2) * param.r + param.p_init(2);
    end_pt(3) = mod(end_pt(3), 2*pi);
    return;
end

%{
 returns the parameter of certain location according to an inititalpoint,
 segment type, and its corresponding parameter
%}

function seg_end = dubins_segment(seg_param, seg_init, seg_type)
    L_SEG = 1;
    S_SEG = 2;
    R_SEG = 3;
    if( seg_type == L_SEG ) 
        seg_end(1) = seg_init(1) + sin(seg_init(3)+seg_param) - sin(seg_init(3));
        seg_end(2) = seg_init(2) - cos(seg_init(3)+seg_param) + cos(seg_init(3));
        seg_end(3) = seg_init(3) + seg_param;
    elseif( seg_type == R_SEG )
        seg_end(1) = seg_init(1) - sin(seg_init(3)-seg_param) + sin(seg_init(3));
        seg_end(2) = seg_init(2) + cos(seg_init(3)-seg_param) - cos(seg_init(3));
        seg_end(3) = seg_init(3) - seg_param;
    elseif( seg_type == S_SEG ) 
        seg_end(1) = seg_init(1) + cos(seg_init(3)) * seg_param;
        seg_end(2) = seg_init(2) + sin(seg_init(3)) * seg_param;
        seg_end(3) = seg_init(3);
    end
end

function err = computeCrosstrackError(state, waypoints)
%COMPUTECROSSTRACKERROR  Signed distance from robot to nearest path segment
%  state is [x; y; theta; ...], waypoints is M×2 [x y].
    p = state(1:2); 
    errMin = Inf;
    for i = 1:size(waypoints,1)-1
        A = waypoints(i, :)';
        B = waypoints(i+1, :)';
        v = B - A;
        w = p - A;
        t = dot(w,v)/dot(v,v);
        t = max(0, min(1, t));        % project onto segment
        proj = A + t*v;
        d = norm(p - proj);
        if d < errMin
            errMin = d;
            % sign = + if robot is to the left of AB (using z-component of cross)
            cp = v(1)*(p(2)-A(2)) - v(2)*(p(1)-A(1));
            signErr = sign(cp);
            err = signErr * d;
        end
    end
end




